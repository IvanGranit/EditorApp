# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'data\untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import glob

import cv2

from canvas import Canvas

from PyQt5.QtCore import QRect, Qt, QSize, QPointF
from PyQt5.QtGui import QColor, QPixmap, QPalette, QImage
from PyQt5.QtCore import QRect, Qt, QSize, QRectF
from PyQt5.QtGui import QColor, QPixmap, QPalette, QIcon
from PyQt5 import QtCore
from PyQt5.QtWidgets import QLabel, QMainWindow, QWidget, QVBoxLayout, QListWidget, QListWidgetItem, QMessageBox, \
    QPushButton, QFileDialog, QApplication, QHBoxLayout, QGraphicsPixmapItem, QGraphicsScene, QGraphicsView, \
    QGraphicsSceneHoverEvent
import json

from canvas import Canvas
from centralLabel import GraphicsScene
from SimpleObjects import SimplePoint, SimpleRect, MiniGraphicsView, MiniSimplePoint, MiniGraphScene
from model import build_model
from centralLabel import GraphicsView

from title_bar import TitleWidget
from main_bar import MainBar, ImageTab
from tool_bar import ToolBar
from side_panel import SidePanel, SB, ListWidget, ListWidgetItem, PinItem
from info_line import InfoLine


class Ui_MainWindow(QMainWindow):

    def __init__(self):
        super().__init__()

        self.images_list = []

        self.setObjectName("MainWindow")
        self.setWindowFlag(Qt.FramelessWindowHint)

        self.central_widget = CentralWidget(self)
        self.central_widget.setObjectName("centralwidget")

        self.setCentralWidget(self.central_widget)
        self.setGeometry(app.desktop().availableGeometry(0))
        self.setWindowIcon(QIcon("src/icons/TestLogo.png"))
        self.showFullScreen()

    def minimize(self):
        self.showMinimized()

    def maximize(self):
        self.showFullScreen()
        self.central_widget.title_bar.MaxButton.setVisible(False)
        self.central_widget.title_bar.RestoreButton.setVisible(True)

    def restore(self):
        self.showNormal()
        self.central_widget.title_bar.MaxButton.setVisible(True)
        self.central_widget.title_bar.RestoreButton.setVisible(False)

    def close(self):
        sys.exit(app.exec_())


class CentralWidget(QWidget):

    def __init__(self, parent=None):
        super().__init__(parent=parent)

        self.w = 510
        self.dict = None
        self.elements_list = ListWidget(self)
        self.circuit_map = MiniGraphicsView(self)

        self.dirlist = None
        self.setupUI()

        self.image_tabs = []
        self.selected_items = []
        self.tab = None
        self.sb = None

        self.load_project()

    def load_project(self):

        self.dirlist = QFileDialog.getExistingDirectory(None, "Выбрать папку", ".")

        if self.dirlist:
            try:
                with open(self.dirlist + r'/Контрольные точки/Points', 'r') as ff:
                    self.dict = json.loads(ff.read(), strict=False)
                    self.title_bar.project_name.setText(f"{self.dirlist.split('/')[-1]}  -  Editor App")
                    self.parent().setWindowTitle(self.dirlist.split('/')[-1])
            except FileNotFoundError:
                message = QMessageBox()
                message.setText('Файл Points не найден,\n найти вручную?')
                message.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                answer = message.exec_()
                if answer == QMessageBox.Yes:
                    dirlist_points, _ = QFileDialog.getOpenFileName(None, "Выбрать папку",
                                                                    self.dirlist + '/Контрольные точки/')
                    if dirlist_points:
                        with open(dirlist_points, 'r') as ff:
                            self.dict = json.loads(ff.read(), strict=False)
                elif answer in (QMessageBox.No, QMessageBox.Close):
                    return

            if self.dict:
                self.elements_list.clear()
                for el in self.dict['Elements'].keys():
                    try:
                        item = ListWidgetItem(el, self.dict['Elements'][el]['Type'], parent=self)
                    except KeyError:
                        item = ListWidgetItem(el, parent=self)

                    item.setText(el)

                    self.elements_list.addItem(item)
                    self.elements_list.setItemWidget(item, item.widget)

                    for pin in self.dict['Elements'][el]['Pins'].keys():
                        try:
                            pin_item = PinItem(f'|-{pin}', self)  # Temp solution
                        except KeyError:
                            pin_item = PinItem(parent=self)

                        pin_item.setText(pin)

                        self.elements_list.addItem(pin_item)
                        self.elements_list.setItemWidget(pin_item, pin_item.pin_label)
                        pin_item.setHidden(True)

                self.elements_list.setCurrentRow(0)
                self.elements_list_clicked()

            for file in glob.glob(self.dirlist + r'\Виды\*'):
                self.create_scene(file)
                self.create_tab(file.split('\\')[-1])
                self.sb = SB(self, file.split('\\')[-1])
                self.side_panel.layout.addWidget(self.sb)
            self.tab_clicked(self.tab)

            self.set_line(f'Elements & images loaded from {self.dirlist}', Qt.darkGreen)
        else:
            self.set_line('Project are not loaded', Qt.red)

    def next_item(self):
        element = self.elements_list.currentItem()
        with open("src/style/neutral/item_el_checked.css") as style:
            style = style.read()
            element.el_label.setStyleSheet(style)
            element.el_type_label.setStyleSheet(style)
            del style
        element.status = True

        self.elements_list.setCurrentRow(self.elements_list.currentRow() + 1)

        while isinstance(self.elements_list.currentItem(), PinItem):
            pin = self.elements_list.currentItem()
            with open("src/style/neutral/item_pin_checked.css") as style:
                style = style.read()
                for item in self.graphics_view.scene().items():
                    if isinstance(item, SimplePoint) and pin.text() == item.object_name:

                        pin.pin_label.setStyleSheet(style)
                        pin.status = True

                del style

            self.elements_list.setCurrentRow(self.elements_list.currentRow() + 1)

        if self.elements_list.currentItem() is None:
            raise AttributeError
        self.elements_list_clicked()

    def highlight_graphic(self, items, flag):
        for item in self.graphics_view.scene().items():
            if type(item) in [SimpleRect, SimplePoint] and item.object_name.split("_")[0] in items:
                if flag:
                    item.hoverEnterEvent(QGraphicsSceneHoverEvent)
                else:
                    item.hoverLeaveEvent(QGraphicsSceneHoverEvent)

        for item in self.circuit_map.items():
            if isinstance(item, MiniSimplePoint) and item.object_name.split("_")[0] in items:
                if flag:
                    item.hoverEnterEvent(QGraphicsSceneHoverEvent)
                else:
                    item.hoverLeaveEvent(QGraphicsSceneHoverEvent)

    def elements_list_clicked(self):
        if self.graphics_view.mod == "AI" and type(self.elements_list.currentItem()) == PinItem:
            while isinstance(self.elements_list.currentItem(), PinItem):
                self.elements_list.setCurrentRow(self.elements_list.currentRow() - 1)
            self.set_line("Can't place pins in AI mode", Qt.darkYellow)
            return

        if isinstance(self.elements_list.currentItem(), ListWidgetItem):
            self.hide_subs()

            for el in self.elements_list.findItems(self.elements_list.currentItem().text(), Qt.MatchStartsWith):
                if el.text().split("_")[0] == self.elements_list.currentItem().text() and type(el) != ListWidgetItem:
                    el.setHidden(False)

        self.set_line(f'{self.elements_list.currentItem().text()} clicked', Qt.darkGreen)

    def hide_subs(self):
        [el.setHidden(True) for el in self.elements_list.findItems("", Qt.MatchStartsWith) if isinstance(el, PinItem)]

    def tab_clicked(self, tab):
        self.sb.hide()
        for element in self.findChildren(GraphicsScene):
            if element.objectName() == tab.text():
                # noinspection PyTypeChecker
                self.graphics_view.setScene(element)
        for element in self.side_panel.findChildren(SB):
            if element.image_name == tab.text():
                self.sb = element
                self.sb.show()
                self.side_panel.slider.setSliderPosition(self.sb.opacity.value())
                return

    def rewrite(self):
        self_dict = self.dict
        for scene in self.findChildren(GraphicsScene):
            for element in scene.items():

                if isinstance(element, SimpleRect):
                    if element.object_name in self_dict['Elements']:
                        self_dict['Elements'][element.object_name] \
                            ['Views'][str(scene.canvas.index)] = \
                            [{'L': int(element.rect().topLeft().x()),
                              'T': int(element.rect().topLeft().y()),
                              'R': int(element.rect().bottomRight().x()),
                              'B': int(element.rect().bottomRight().y()),
                              'Section': element.object_name}]

                if isinstance(element, SimplePoint):
                    if element.object_name in self_dict['Dots']:
                        self_dict['Dots'][element.object_name] \
                            ['Views'][str(scene.canvas.index)] = \
                            {'L': int(element.rect().topLeft().x()),
                             'T': int(element.rect().topLeft().y()),
                             'R': int(element.rect().bottomRight().x()),
                             'B': int(element.rect().bottomRight().y()),
                             'Section': element.object_name}

        with open(self.dirlist + '/Контрольные точки/Points', 'w') as ff:
            json.dump(self_dict, ff, indent=1)
        self.set_line(f'File {self.dirlist}/Контрольные точки/Points rewrote', Qt.darkGreen)

    def create_tab(self, name="Empty"):
        self.tab = ImageTab(self)
        self.tab.setText(name)
        self.main_bar.layout.addWidget(self.tab)

    def create_scene(self, path):
        canvas = Canvas(path, model=model)
        scene = GraphicsScene(self.graphics_view, canvas)
        scene.setObjectName(path.split('\\')[-1])
        scene.itemClicked.connect(self.itemClicked)
        scene.itemMoved.connect(self.sim_moved)

        self.graphics_view.setScene(scene)

    def sim_moved(self, data):
        if self.circuit_map.scene() is not None:
            if self.graphics_view.objectName() != data['source']:
                graph = self.graphics_view
                kx, ky = 1/self.kx, 1/self.ky
            else:
                graph = self.circuit_map
                kx, ky = self.kx, self.ky

            for item in graph.scene().items():
                if isinstance(item, SimplePoint):
                    if item.object_name == data['object_name']:
                        point = item
                        break

            point.setPos(point.scenePos().x() + data['delta_x'] * kx, point.scenePos().y() + data['delta_y'] * ky)

    def itemClicked(self, item):

        if isinstance(item, SimpleRect):

            k = self.circuit_map.width() / self.circuit_map.height()

            pos_rect = item.mapRectToScene(item.z_rect)

            # Находим координаты центра
            y_center = pos_rect.y() + (pos_rect.height() / 2)

            # Подгоняем высоту под соотношение зиккурата
            pos_rect.setHeight(pos_rect.width() / k)

            # Находим разницу старого Y от нового
            dif = pos_rect.y() - (y_center - (pos_rect.height() / 2))

            # Корректируем размер четырехугольника по вертикальной оси
            pos_rect.setY(y_center - (pos_rect.height() / 2))
            pos_rect.setHeight(pos_rect.height() - dif)
            if pos_rect.x() < 0 or pos_rect.y() < 0:
                self.set_line('Wrong position of element', Qt.Red)
                return

            y = int(pos_rect.x())
            x = int(pos_rect.y())
            y1 = int(pos_rect.x() + pos_rect.width())
            x1 = int(pos_rect.y() + pos_rect.height())

            img = Canvas.read_image(self.graphics_view.scene().canvas.path)

            cut_image = img[x: x1, y: y1]
            height, width, _ = cut_image.shape
            cut_image = QImage(bytes(cut_image), width, height, width * 3, QImage.Format_RGB888)
            scene = MiniGraphScene(self.circuit_map)
            scene.itemMoved.connect(self.sim_moved)
            scene.itemClicked.connect(self.add_item)

            pic = QGraphicsPixmapItem()
            pic.setPixmap(QPixmap.fromImage(cut_image).scaled(self.circuit_map.size(), Qt.KeepAspectRatio))
            scene.addItem(pic)

            self.circuit_map.setScene(scene)

            self.kx = self.circuit_map.size().width() / width
            self.ky = self.circuit_map.size().height() / height

            points = [item for item in self.graphics_view.scene().items() if isinstance(item, SimplePoint)]
            for point in points:
                pos_point = point.mapRectToScene(point.rect())
                x = (pos_point.x() - pos_rect.x()) * 4 * self.kx
                y = (pos_point.y() - pos_rect.y()) * 4 * self.ky
                rect = MiniSimplePoint((x, y), object_name=point.object_name)
                self.circuit_map.scene().addItem(rect)

            del img

        if isinstance(item, (SimpleRect, SimplePoint)):
            self.add_item(item)
            # self.set_line(f'{item.object_name} selected', Qt.green)

    def add_item(self, item):

        self.selected_items = []

        self.selected_items.append(item)

        if isinstance(item, (SimplePoint, MiniSimplePoint)):

            if item.scene().parent() == self.graphics_view:
                items = [it for it in self.circuit_map.scene().items() if isinstance(it, MiniSimplePoint)]
                [self.selected_items.append(it) for it in items if it.object_name == item.object_name]

            if item.scene().parent() == self.circuit_map:
                items = [it for it in self.graphics_view.scene().items() if isinstance(it, SimplePoint)]
                [self.selected_items.append(it) for it in items if it.object_name == item.object_name]

        self.set_line(f'Selected {[it.object_name for it in self.selected_items]}', Qt.green)

    def keyPressEvent(self, event):

        if event.key() == Qt.Key_Delete:
            if len(self.selected_items) != 0:
                for item in self.selected_items:
                    item.scene().removeItem(item)
                self.selected_items = []

    def set_line(self, text=None, color=None):
        self.info_line.setText(text)
        if color:
            palette = QPalette()
            palette.setColor(QPalette.Text, color)
            self.info_line.setPalette(palette)

    def mod_AI(self):
        self.graphics_view.mod = 'AI'
        self.elements_list_clicked()
        self.set_line('AI mod', Qt.green)

    def mod_STANDARD(self):
        self.graphics_view.mod = 'standard'
        self.set_line('Standard mod', Qt.green)

    def mod_AXE(self):
        self.graphics_view.mod = 'Axe'
        self.set_line('Axe mod', Qt.green)

    def setupUI(self):
        self.tool_bar = ToolBar(self)
        self.tool_bar.move(0, 30)

        self.side_panel = SidePanel(self)
        self.side_panel.setGeometry(1620, 30, 300, 1050)

        self.title_bar = TitleWidget(self)
        self.title_bar.setGeometry(0, 0, 1920, 30)
        self.title_bar.MinButton.clicked.connect(self.parent().minimize)
        self.title_bar.MaxButton.clicked.connect(self.parent().maximize)
        self.title_bar.RestoreButton.clicked.connect(self.parent().restore)
        self.title_bar.CloseButton.clicked.connect(self.parent().close)

        self.main_bar = MainBar(self)
        self.main_bar.setGeometry(50, 30, 1920-300-50, 35)

        self.info_line = InfoLine(self)
        self.info_line.setGeometry(0, 1050, 1920, 30)
        self.info_line.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)

        self.elements_list.clicked.connect(self.elements_list_clicked)

        self.circuit_map.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.circuit_map.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.graphics_view = GraphicsView(self)
        self.graphics_view.setObjectName('MainView')
        self.graphics_view.setGeometry(50, 65, 1920-300-50, 1080-30-65)




if __name__ == "__main__":
    import sys

    model = build_model()
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    model.load_weights('data/U-net/weights.hdf5')

    app = QApplication(sys.argv)
    ui = Ui_MainWindow()
    ui.show()
    sys.exit(app.exec_())
